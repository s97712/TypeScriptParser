using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

[Generator]
public class AdditionalFilesTestGenerator : IIncrementalGenerator
{
    static AdditionalFilesTestGenerator()
    {
        // 设置 native 库解析器，重定向到源生成器程序集目录
        // NativeLibrary.SetDllImportResolver(typeof(TypeScriptParser.Parser).Assembly, DllImportResolver);
    }

    public static string GetApplicationPath()
    {
        var assembly = Assembly.GetExecutingAssembly();
        var location = assembly.Location;
        return location;
    }

    private static string ExeDir = GetApplicationPath();

    private static List<string> _resolverDebugInfo = new List<string> { "DllImportResolver未被调用." };

    private static IntPtr DllImportResolver(string libraryName, Assembly assembly, DllImportSearchPath? searchPath)
    {
        // 记录调试信息到全局变量供后续输出
        _resolverDebugInfo.Add($"获取 {libraryName}");

        // 获取源生成器程序集目录
        var assemblyDir = ExeDir;

        if (!string.IsNullOrEmpty(assemblyDir))
        {
            // 构建可能的库文件路径
            var possiblePaths = new[]
            {
                Path.Combine(assemblyDir, $"lib{libraryName}.so"),
                Path.Combine(assemblyDir, $"{libraryName}.so"),
                Path.Combine(assemblyDir, $"{libraryName}.dll")
            };

            foreach (var path in possiblePaths)
            {
                try
                {
                    _resolverDebugInfo.Add($"尝试加载1 '{path}'");
                    return NativeLibrary.Load(path);
                }
                catch (Exception _)
                {
                    _resolverDebugInfo.Add($"加载 '{path}' 失败");
                }
            }
            _resolverDebugInfo.Add($"加载 ${libraryName} 失败");
        }
        
        // 回退到默认行为
        return IntPtr.Zero;
    }
    

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 无论如何都生成代码
        context.RegisterPostInitializationOutput(GenerateBasicCode);
    }

    private static string Parse()
    {
        try
        {

            var parser = new TypeScriptParser.Parser();
            var tree = parser.ParseString("const x = 1;");
            if (tree.root_node().is_null() == false)
            {
                return "TypeScriptParser native 库加载成功，成功解析代码";
            }
            else
            {
                return "TypeScriptParser 创建成功但解析失败";
            }
        }
        catch
        {
            return "TypeScriptParser 加载失败";

        }
    }


    private static void GenerateBasicCode(IncrementalGeneratorPostInitializationContext context)
    {
        // var sourceBuilder = new StringBuilder();
        // var parserTestResult = Parse();

        var source = $$"""
            // <auto-generated />
            // 这是基础生成的代码，证明源生成器正在工作
            using System;

            namespace TypeScriptParser.SourceGeneratorTest
            {
                public static class GeneratorStatus
                {
                    public static void PrintStatus()
                    {
                    
                        Console.WriteLine($"BasePath: {{Assembly.GetExecutingAssembly()}}");
                        Console.WriteLine($"BasePath: {{Assembly.GetExecutingAssembly().Location}}");
                    }
                }
            }
            """;
        context.AddSource("GeneratorStatus.g.cs", source);
    }

}